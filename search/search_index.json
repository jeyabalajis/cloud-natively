{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Cloud Natively Hello there! Welcome to this portal. The intent of this portal is to provide you with a comprehensive overview of what a cloud native application is, it's benefits on software delivery and how you can approach building cloud native applications. We start with a high level overview of what a Cloud Native software application is, and then delve deeper into the various constituents. Hope you enjoy this guide! Cloud Natively - A comprehensive overview of Cloud Native applications What is Cloud Native? Cloud Native applications allow your organization to ship faster, reduce risk, and grow your business. Cloud native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. When companies build and operate applications using a cloud native architecture, they bring new ideas to market faster and respond sooner to customer demands. Cloud Native is the answer to the software industry\u2019s relentless search in the current decade for a set of tools and practices that makes your software easily deployable, modular, maintainable, robust, reliable, scalable, portable and observable \u2014 all at once. Under the hood, a Cloud Native architecture is supported by these key architecture patterns and processes. Containers Microservices Continuous Delivery DevOps Containers Containers are a great enabler of Cloud Native software. Containerization is the first step towards making your software portable to cloud & scalable thereof. Containerization is normally done with Docker containers, but there are alternatives like rkt too. Any size application and dependencies can be containerized However, you should aspire towards composing a set of highly cohesive functionality into a single container. Containerizing a service is simple and straightforward. The code, its dependencies, and runtime are packaged into a binary called a container image. Images are stored in a container registry, which acts as a repository or library for images. A registry can be located on your development computer, in your data center, or in a public cloud. Docker itself maintains a public registry via Docker Hub. While several container vendors exist, Docker has captured the lion's share of the market. The company has been driving the software container movement. It has become the de facto standard for packaging, deploying, and running cloud-native applications. Why Containers? Containers provide portability and guarantee consistency across environments. By encapsulating everything into a single package, you isolate the service (that provides a set of cohesive functionality) and its dependencies from the underlying infrastructure . Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines. You can deploy the container in any environment that hosts the Docker runtime engine . By sharing the underlying operating system and host resources, a container has a much smaller footprint than a full virtual machine . The smaller size increases the density, or number of services, that a given host can run at one time. Container Orchestration While tools such as Docker allow you to create container images and run them, you need additional abstractions to manage them (i.e. scale out or in based on demand, apply revisions based on new versions, expose containers as services to the outside world etc.) While several container orchestrators exist, Kubernetes has become the de facto standard for the cloud-native world. It's a portable, extensible, open-source platform for managing containerized workloads. Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available. Kubernetes brings infrastructure-level concerns like load balancing, networking, storage, and compute into app configuration - this makes it hard to understand, but it is worth it. Kubernetes is a platform for running containers. This includes, but not limited to, the folowing capabilities: Start your containerized applications Roll out updates or revisions to software in a phased manner Maintain service levels Scale to meet demand Secure access Provide external storage for stateful apps Provide network traffic routing The joy of working with Kubernetes is that it adds a layer of consistency on top of all your apps\u2014old .NET and Java monoliths and new Node.js and Go microservices are all described, deployed, and managed in the same way. All major cloud providers offer managed Kubernetes as a service, which allows you to deliver scalable containerized applications fast. Microservices Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications. The term Microservices refers to an architectural approach based on multiple smaller, modular services. Each microservice has it's own codebase and is usually owned and maintained by a separate small team. A background in Domain Driven Design is essential to structure microservices. Domain Driven Design: \u201cA specific sphere of activity or knowledge that defines a set of common requirements, terminology, and functionality on which the application logic works to solve a problem.\u201d It focuses mainly on a business problem and how to strictly organize the logic that solves it. This approach was first described by Eric Evans in his book Domain-Driven Design Tackling Complexity in the Heart of Software . Bounded Context In Domain Driven Design, Bounded Context is a way to break the domain into multiple cohesive wholes, each of which have their own unified model both in concept and in code. For example, let us say you are building a software platform to offer Supply Chain Financing as a Service. Here Supply Chain Financing is the domain. Some of the bounded contexts could be as follows: Origination : The process flow that on-boards a small business and provides them with a credit limit) Financing : The process flow that starts with a small business submitting an invoice & ends with the invoice being funded through credit limit consumption Rewards : Gamified update of credit limits, based on the repayment behavior of the small business You can structure each of the above sub-domains as a set of microservices, each providing a cohesive set of functionality. The following patterns are available for you to divide a domain into bounded contexts: Decompose by Sub-Domain Decompose by Business Capability Key Characteristics of Microservices Each service implements a specific business capability within a larger domain context. Each service is developed autonomously and can be deployed and scaled independently . Each service is self-contained encapsulating its own data storage technology, dependencies, and programming platform. The services are not aware of other services that live outside the bounded context . I.e. the services are Loosely coupled . When you embark on your journey to build your software application as a set of microservices, always start with the domain and discover bounded contexts within your domain. This allows you to build your application as a set of cohesive and loosely coupled services. When you build microservices, embrace the philosophy of Twelve Factor Apps Why Microservices The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack. Continuous Delivery Continuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time. With Continuous Delivery - Software is checked-in, tested, packaged and deployed in multiple increments throughout the day. - You can perform push-button deployments of any version of the software to any environment on demand The key steps to accomplishing Continuous Delivery are as follows: Continuously Integrate the software developed by the development team Run automated tests on the integrated software Build a container image, tag/version appropriately and push into a container registry Deploy the software version from registry into an environment. Steps 1 & 2 together is usually referred to as Continous Integration . Continuous Delivery builds on this, dealing with the final stages required for production deployment. Step 3 can either be automated (or) can be managed as a manual release through tags. Step 4 can either be done automatically (or) can be managed as a manual deployment step. Continuous Delivery just means that you are able to do frequent deployments but may choose not to do it, usually due to businesses preferring a slower rate of deployment. Why Continuous Delivery Reduced Deployment Risk : Since software is deployed in increments, you control what's changing and it is easier to rollback if needed. We delver deeper into safe deployment mechanisms (such as blue/green) in the further chapters. User Feedback : This is the biggest benefit of continuous delivery. Working software is presented in front of real users more frequently, which in turns allows you to gather critical feedback and perform course correction to your roadmap. Implementing Continuous Delivery The following practices helps your team to implement continuous delivery and accomplish higher throughput and lower risk releases: Test Automation : The use of comprehensive automated test suites primarily created and maintained by developers. Effective test suites are reliable \u2014 that is, tests find real failures and only pass releasable code . Code Maintainability : Make it easy for developers to change code maintained by others, to reuse other people's code, and to add, upgrade, and migrate to new versions of dependencies without breaking their code. Continuous Integration : A development practice where code is regularly checked in, and each check-in triggers a set of quick tests to discover regressions, which developers fix immediately. The CI process creates canonical builds and packages that are ultimately deployed and released. Continuous testing : Testing throughout the software delivery lifecycle rather than as a separate phase after dev complete. A loosely coupled architecture : Architecture that lets teams test and deploy their applications on demand, without requiring orchestration with other services. Deployment automation : The degree to which deployments are fully automated and do not require manual intervention. DevOps The patterns and practices that enable faster, more reliable releases to deliver value to the business are collectively known as DevOps. Unlike the previous constituents (Containers, Microservices & Continuous Delivery), DevOps is not just about Technology. It is a combination of People, Processes & Technology and it is a Continuous Journey , rather than a destination. If you are operating with the highest levels of DevOps maturity, you reap the following benefits: Increase the speed of your deployments Improve the stability of your software Build security in from the start The capabilities that DevOps encompasses are well documented. See here for a comprehensive take on DevOps. Why DevOps Increased Collaboration and Trust Release Faster and work Smarter Accelerate Time-to-Resolution Better Manage unplanned work CALMS Framework CALMS is a framework that assesses a company's ability to adopt DevOps processes, as well as a way of measuring success during a DevOps transformation. The acronym was coined by Jez Humble, co-author of \u201cThe DevOps Handbook,\u201d and stands for Culture , Automation , Lean Product Development , Measurement , and Sharing . Lean Product Development You can increase your software delivery performance, organizational performance, and decrease burnout by focusing on the following four capabilities: Working in small batches Teams break products and features into small batches that can be completed in less than a week and released frequently, including the use of MVPs (minimum viable products). Visibility of work in the value stream Teams understand the workflow from business to customers, and whether they have visibility into this flow, including the status of products and features. Mapping the value stream is a lean principle . The goal of value stream mapping is to use the customer\u2019s value as a reference point and identify all the activities that contribute to these values. Activities that do not add value to the end customer are considered waste. Customer feedback Organizations actively and regularly seek customer feedback and incorporate it into their product design. Team experimentation Development teams have the authority to create and change specifications as part of the development process without requiring approval. DevOps Maturity Assessment The following are some of the key metrics you can use to track the current DevOps maturity of your organization: Deployment Frequency For the primary application or service you work on, how often does your organization deploy code to production or release it to end users? Lead Time for Changes For the primary application or service you work on, what is your lead time for changes (i.e., how long does it take to go from code committed to code successfully running in production)? Mean Time to Restore (MTTR) For the primary application or service you work on, how long does it generally take to restore service when a service incident or a defect that impacts users occurs (e.g., unplanned outage or service impairment)? Change Fail Rate For the primary application or service you work on, what percentage of changes to production or released to users result in degraded service (e.g., lead to service impairment or service outage) and subsequently require remediation (e.g., require a hotfix, rollback, fix forward, patch)? References Cloud Native - Definition Scaling Cloud Native Apps Kubernetes Overview Beyond the Twelve Factor App Microservices Architecture & Patterns The Five Principles of Lean DevOps Research & Assessment Continuous Delivery is not just a technical activity","title":"Home"},{"location":"index.html#cloud-natively","text":"Hello there! Welcome to this portal. The intent of this portal is to provide you with a comprehensive overview of what a cloud native application is, it's benefits on software delivery and how you can approach building cloud native applications. We start with a high level overview of what a Cloud Native software application is, and then delve deeper into the various constituents. Hope you enjoy this guide! Cloud Natively - A comprehensive overview of Cloud Native applications","title":"Cloud Natively"},{"location":"index.html#what-is-cloud-native","text":"Cloud Native applications allow your organization to ship faster, reduce risk, and grow your business. Cloud native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. When companies build and operate applications using a cloud native architecture, they bring new ideas to market faster and respond sooner to customer demands. Cloud Native is the answer to the software industry\u2019s relentless search in the current decade for a set of tools and practices that makes your software easily deployable, modular, maintainable, robust, reliable, scalable, portable and observable \u2014 all at once. Under the hood, a Cloud Native architecture is supported by these key architecture patterns and processes. Containers Microservices Continuous Delivery DevOps","title":"What is Cloud Native?"},{"location":"index.html#containers","text":"Containers are a great enabler of Cloud Native software. Containerization is the first step towards making your software portable to cloud & scalable thereof. Containerization is normally done with Docker containers, but there are alternatives like rkt too. Any size application and dependencies can be containerized However, you should aspire towards composing a set of highly cohesive functionality into a single container. Containerizing a service is simple and straightforward. The code, its dependencies, and runtime are packaged into a binary called a container image. Images are stored in a container registry, which acts as a repository or library for images. A registry can be located on your development computer, in your data center, or in a public cloud. Docker itself maintains a public registry via Docker Hub. While several container vendors exist, Docker has captured the lion's share of the market. The company has been driving the software container movement. It has become the de facto standard for packaging, deploying, and running cloud-native applications.","title":"Containers"},{"location":"index.html#why-containers","text":"Containers provide portability and guarantee consistency across environments. By encapsulating everything into a single package, you isolate the service (that provides a set of cohesive functionality) and its dependencies from the underlying infrastructure . Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines. You can deploy the container in any environment that hosts the Docker runtime engine . By sharing the underlying operating system and host resources, a container has a much smaller footprint than a full virtual machine . The smaller size increases the density, or number of services, that a given host can run at one time.","title":"Why Containers?"},{"location":"index.html#container-orchestration","text":"While tools such as Docker allow you to create container images and run them, you need additional abstractions to manage them (i.e. scale out or in based on demand, apply revisions based on new versions, expose containers as services to the outside world etc.) While several container orchestrators exist, Kubernetes has become the de facto standard for the cloud-native world. It's a portable, extensible, open-source platform for managing containerized workloads. Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available. Kubernetes brings infrastructure-level concerns like load balancing, networking, storage, and compute into app configuration - this makes it hard to understand, but it is worth it. Kubernetes is a platform for running containers. This includes, but not limited to, the folowing capabilities: Start your containerized applications Roll out updates or revisions to software in a phased manner Maintain service levels Scale to meet demand Secure access Provide external storage for stateful apps Provide network traffic routing The joy of working with Kubernetes is that it adds a layer of consistency on top of all your apps\u2014old .NET and Java monoliths and new Node.js and Go microservices are all described, deployed, and managed in the same way. All major cloud providers offer managed Kubernetes as a service, which allows you to deliver scalable containerized applications fast.","title":"Container Orchestration"},{"location":"index.html#microservices","text":"Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications. The term Microservices refers to an architectural approach based on multiple smaller, modular services. Each microservice has it's own codebase and is usually owned and maintained by a separate small team. A background in Domain Driven Design is essential to structure microservices. Domain Driven Design: \u201cA specific sphere of activity or knowledge that defines a set of common requirements, terminology, and functionality on which the application logic works to solve a problem.\u201d It focuses mainly on a business problem and how to strictly organize the logic that solves it. This approach was first described by Eric Evans in his book Domain-Driven Design Tackling Complexity in the Heart of Software .","title":"Microservices"},{"location":"index.html#bounded-context","text":"In Domain Driven Design, Bounded Context is a way to break the domain into multiple cohesive wholes, each of which have their own unified model both in concept and in code. For example, let us say you are building a software platform to offer Supply Chain Financing as a Service. Here Supply Chain Financing is the domain. Some of the bounded contexts could be as follows: Origination : The process flow that on-boards a small business and provides them with a credit limit) Financing : The process flow that starts with a small business submitting an invoice & ends with the invoice being funded through credit limit consumption Rewards : Gamified update of credit limits, based on the repayment behavior of the small business You can structure each of the above sub-domains as a set of microservices, each providing a cohesive set of functionality. The following patterns are available for you to divide a domain into bounded contexts: Decompose by Sub-Domain Decompose by Business Capability","title":"Bounded Context"},{"location":"index.html#key-characteristics-of-microservices","text":"Each service implements a specific business capability within a larger domain context. Each service is developed autonomously and can be deployed and scaled independently . Each service is self-contained encapsulating its own data storage technology, dependencies, and programming platform. The services are not aware of other services that live outside the bounded context . I.e. the services are Loosely coupled . When you embark on your journey to build your software application as a set of microservices, always start with the domain and discover bounded contexts within your domain. This allows you to build your application as a set of cohesive and loosely coupled services. When you build microservices, embrace the philosophy of Twelve Factor Apps","title":"Key Characteristics of Microservices"},{"location":"index.html#why-microservices","text":"The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.","title":"Why Microservices"},{"location":"index.html#continuous-delivery","text":"Continuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time. With Continuous Delivery - Software is checked-in, tested, packaged and deployed in multiple increments throughout the day. - You can perform push-button deployments of any version of the software to any environment on demand The key steps to accomplishing Continuous Delivery are as follows: Continuously Integrate the software developed by the development team Run automated tests on the integrated software Build a container image, tag/version appropriately and push into a container registry Deploy the software version from registry into an environment. Steps 1 & 2 together is usually referred to as Continous Integration . Continuous Delivery builds on this, dealing with the final stages required for production deployment. Step 3 can either be automated (or) can be managed as a manual release through tags. Step 4 can either be done automatically (or) can be managed as a manual deployment step. Continuous Delivery just means that you are able to do frequent deployments but may choose not to do it, usually due to businesses preferring a slower rate of deployment.","title":"Continuous Delivery"},{"location":"index.html#why-continuous-delivery","text":"Reduced Deployment Risk : Since software is deployed in increments, you control what's changing and it is easier to rollback if needed. We delver deeper into safe deployment mechanisms (such as blue/green) in the further chapters. User Feedback : This is the biggest benefit of continuous delivery. Working software is presented in front of real users more frequently, which in turns allows you to gather critical feedback and perform course correction to your roadmap.","title":"Why Continuous Delivery"},{"location":"index.html#implementing-continuous-delivery","text":"The following practices helps your team to implement continuous delivery and accomplish higher throughput and lower risk releases: Test Automation : The use of comprehensive automated test suites primarily created and maintained by developers. Effective test suites are reliable \u2014 that is, tests find real failures and only pass releasable code . Code Maintainability : Make it easy for developers to change code maintained by others, to reuse other people's code, and to add, upgrade, and migrate to new versions of dependencies without breaking their code. Continuous Integration : A development practice where code is regularly checked in, and each check-in triggers a set of quick tests to discover regressions, which developers fix immediately. The CI process creates canonical builds and packages that are ultimately deployed and released. Continuous testing : Testing throughout the software delivery lifecycle rather than as a separate phase after dev complete. A loosely coupled architecture : Architecture that lets teams test and deploy their applications on demand, without requiring orchestration with other services. Deployment automation : The degree to which deployments are fully automated and do not require manual intervention.","title":"Implementing Continuous Delivery"},{"location":"index.html#devops","text":"The patterns and practices that enable faster, more reliable releases to deliver value to the business are collectively known as DevOps. Unlike the previous constituents (Containers, Microservices & Continuous Delivery), DevOps is not just about Technology. It is a combination of People, Processes & Technology and it is a Continuous Journey , rather than a destination. If you are operating with the highest levels of DevOps maturity, you reap the following benefits: Increase the speed of your deployments Improve the stability of your software Build security in from the start The capabilities that DevOps encompasses are well documented. See here for a comprehensive take on DevOps.","title":"DevOps"},{"location":"index.html#why-devops","text":"Increased Collaboration and Trust Release Faster and work Smarter Accelerate Time-to-Resolution Better Manage unplanned work","title":"Why DevOps"},{"location":"index.html#calms-framework","text":"CALMS is a framework that assesses a company's ability to adopt DevOps processes, as well as a way of measuring success during a DevOps transformation. The acronym was coined by Jez Humble, co-author of \u201cThe DevOps Handbook,\u201d and stands for Culture , Automation , Lean Product Development , Measurement , and Sharing .","title":"CALMS Framework"},{"location":"index.html#lean-product-development","text":"You can increase your software delivery performance, organizational performance, and decrease burnout by focusing on the following four capabilities:","title":"Lean Product Development"},{"location":"index.html#working-in-small-batches","text":"Teams break products and features into small batches that can be completed in less than a week and released frequently, including the use of MVPs (minimum viable products).","title":"Working in small batches"},{"location":"index.html#visibility-of-work-in-the-value-stream","text":"Teams understand the workflow from business to customers, and whether they have visibility into this flow, including the status of products and features. Mapping the value stream is a lean principle . The goal of value stream mapping is to use the customer\u2019s value as a reference point and identify all the activities that contribute to these values. Activities that do not add value to the end customer are considered waste.","title":"Visibility of work in the value stream"},{"location":"index.html#customer-feedback","text":"Organizations actively and regularly seek customer feedback and incorporate it into their product design.","title":"Customer feedback"},{"location":"index.html#team-experimentation","text":"Development teams have the authority to create and change specifications as part of the development process without requiring approval.","title":"Team experimentation"},{"location":"index.html#devops-maturity-assessment","text":"The following are some of the key metrics you can use to track the current DevOps maturity of your organization:","title":"DevOps Maturity Assessment"},{"location":"index.html#deployment-frequency","text":"For the primary application or service you work on, how often does your organization deploy code to production or release it to end users?","title":"Deployment Frequency"},{"location":"index.html#lead-time-for-changes","text":"For the primary application or service you work on, what is your lead time for changes (i.e., how long does it take to go from code committed to code successfully running in production)?","title":"Lead Time for Changes"},{"location":"index.html#mean-time-to-restore-mttr","text":"For the primary application or service you work on, how long does it generally take to restore service when a service incident or a defect that impacts users occurs (e.g., unplanned outage or service impairment)?","title":"Mean Time to Restore (MTTR)"},{"location":"index.html#change-fail-rate","text":"For the primary application or service you work on, what percentage of changes to production or released to users result in degraded service (e.g., lead to service impairment or service outage) and subsequently require remediation (e.g., require a hotfix, rollback, fix forward, patch)?","title":"Change Fail Rate"},{"location":"index.html#references","text":"Cloud Native - Definition Scaling Cloud Native Apps Kubernetes Overview Beyond the Twelve Factor App Microservices Architecture & Patterns The Five Principles of Lean DevOps Research & Assessment Continuous Delivery is not just a technical activity","title":"References"},{"location":"continuous_delivery/basics.html","text":"Continuous Delivery - Basics Continuous Delivery is the ability to get changes of all types\u2014including new features, configuration changes, bug fixes and experiments\u2014into production, or into the hands of users, safely and quickly in a sustainable way. Principles There are five principles at the heart of continuous delivery: Build quality in : It\u2019s much cheaper to fix problems and defects if we find them immediately\u2014ideally before they are ever checked into version control, by running automated tests locally. Work in small batches : In continuous delivery, we try and get every change in version control as far towards release as we can, gettting comprehensive feedback as rapidly as possible. Computers perform repetitive tasks, people solve problems : Use automation to perform simple, repetitive tasks, and free up humans to focus on problem-solving. Relentlessly pursue continuous improvement : Don\u2019t treat transformation as a project to be embarked on and then completed so we can return to business as usual. Embrace Kaizen, and treat Continuous Delivery as a Continuous Journey. Everyone is responsible : In high performing organizations, nothing is \u201csomebody else\u2019s problem.\u201d Everyone works together to achieve the organizational level goals, rather than optimizing for what\u2019s best for their team or department.","title":"Basics"},{"location":"continuous_delivery/basics.html#continuous-delivery-basics","text":"Continuous Delivery is the ability to get changes of all types\u2014including new features, configuration changes, bug fixes and experiments\u2014into production, or into the hands of users, safely and quickly in a sustainable way.","title":"Continuous Delivery - Basics"},{"location":"continuous_delivery/basics.html#principles","text":"There are five principles at the heart of continuous delivery: Build quality in : It\u2019s much cheaper to fix problems and defects if we find them immediately\u2014ideally before they are ever checked into version control, by running automated tests locally. Work in small batches : In continuous delivery, we try and get every change in version control as far towards release as we can, gettting comprehensive feedback as rapidly as possible. Computers perform repetitive tasks, people solve problems : Use automation to perform simple, repetitive tasks, and free up humans to focus on problem-solving. Relentlessly pursue continuous improvement : Don\u2019t treat transformation as a project to be embarked on and then completed so we can return to business as usual. Embrace Kaizen, and treat Continuous Delivery as a Continuous Journey. Everyone is responsible : In high performing organizations, nothing is \u201csomebody else\u2019s problem.\u201d Everyone works together to achieve the organizational level goals, rather than optimizing for what\u2019s best for their team or department.","title":"Principles"},{"location":"continuous_delivery/continuous_integration.html","text":"Continuous Integration When your organization practices CI, your developers integrate all their work into the main version of the code base (known as trunk , main, or mainline) on a regular basis. Trunk-based development is a required practice for continuous integration. Continuous integration (CI) is the combination of practicing trunk-based development and maintaining a suite of fast automated tests that run after each commit to trunk to make sure the system is always working. Working in Small Batches Practicing trunk-based development requires in turn that developers understand how to break their work up into small batches. To achieve higher levels of software delivery and operational performance, follow these practices: Have three or fewer active branches in the application's code repository. Merge branches to trunk at least once a day. Don't have code freezes and don't have integration phases. The key is to start development at the service or API layer, not at the UI layer. In this way, you can make additions to the API that won't initially be available to users of the app, and check those changes into trunk. You can launch these changes to production without making them visible to users. This approach, called dark launching, allows developers to check in code for small batches that have been completed, but for features that are not yet fully complete. You can then run automated tests against these changes to prove that they behave in the expected way. This way, teams are still working quickly and developing off of trunk and not long-lived feature branches.","title":"Continuous Integration"},{"location":"continuous_delivery/continuous_integration.html#continuous-integration","text":"When your organization practices CI, your developers integrate all their work into the main version of the code base (known as trunk , main, or mainline) on a regular basis. Trunk-based development is a required practice for continuous integration. Continuous integration (CI) is the combination of practicing trunk-based development and maintaining a suite of fast automated tests that run after each commit to trunk to make sure the system is always working.","title":"Continuous Integration"},{"location":"continuous_delivery/continuous_integration.html#working-in-small-batches","text":"Practicing trunk-based development requires in turn that developers understand how to break their work up into small batches. To achieve higher levels of software delivery and operational performance, follow these practices: Have three or fewer active branches in the application's code repository. Merge branches to trunk at least once a day. Don't have code freezes and don't have integration phases. The key is to start development at the service or API layer, not at the UI layer. In this way, you can make additions to the API that won't initially be available to users of the app, and check those changes into trunk. You can launch these changes to production without making them visible to users. This approach, called dark launching, allows developers to check in code for small batches that have been completed, but for features that are not yet fully complete. You can then run automated tests against these changes to prove that they behave in the expected way. This way, teams are still working quickly and developing off of trunk and not long-lived feature branches.","title":"Working in Small Batches"}]}